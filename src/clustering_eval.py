# -*- coding: utf-8 -*-
"""Clustering_eval.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ma438JEEW08CMDjnE1q8RicG-W2y4lUf
"""

from imports import *
from dataset import dataloader, dataset
from model_mobilenet import model
from utils import extract_features, sobel_filter, evaluate_segmentation_quality, compare_methods
from global import device

# Extract spatial features from intermediate layers
features_spatial = []

with torch.no_grad():
    for images, _ in dataloader:
        images = images.to(device)
        feat = extract_features(model, images)  # [B, C, H, W]
        B, C, H, W = feat.shape
        feat_flat = feat.permute(0, 2, 3, 1).reshape(-1, C)
        features_spatial.append(feat_flat.cpu().numpy())

features = np.concatenate(features_spatial, axis=0)

# Randomly sample 5000 features to reduce computational cost
N = 5000
idx_sample = np.random.choice(features.shape[0], size=N, replace=False)
features_sampled = features[idx_sample]

# Dimensionality reduction with PCA
pca = PCA(n_components=10)
features_reduced = pca.fit_transform(features_sampled)

# KMeans and GMM clustering
kmeans = KMeans(n_clusters=9, random_state=42)
gmm = GaussianMixture(n_components=9, covariance_type='tied', random_state=42)

kmeans_labels = kmeans.fit_predict(features_reduced)
gmm_labels = gmm.fit_predict(features_reduced)

# Evaluation of clustering
kmeans_results = evaluate_segmentation_quality(features_reduced, kmeans_labels, "KMeans")
gmm_results = evaluate_segmentation_quality(features_reduced, gmm_labels, "GMM+PCA")

results = {
    'KMeans': kmeans_results,
    'GMM': gmm_results
}
best = compare_methods(results)

# Global segmentation over full dataset
features_reduced_full = pca.transform(features)
kmeans_labels_full = kmeans.predict(features_reduced_full)
gmm_labels_full = gmm.predict(features_reduced_full)

# Local segmentation on selected samples
indices = [0, 29, 99]
selected_imgs = [dataset[i][0] for i in indices]
selected_imgs_tensor = torch.stack(selected_imgs).to(device)

with torch.no_grad():
    feat = extract_features(model, selected_imgs_tensor)  # [B, C, H, W]
    edges = sobel_filter(feat)
    feat_augmented = torch.cat([feat, edges], dim=1)

B, C_aug, H, W = feat_augmented.shape
feat_flat = feat_augmented.permute(0, 2, 3, 1).reshape(-1, C_aug).cpu().numpy()

pca = PCA(n_components=10)
features_reduced_local = pca.fit_transform(feat_flat)

kmeans_masks = KMeans(n_clusters=9, random_state=42).fit_predict(features_reduced_local).reshape(B, H, W)
gmm_masks = GaussianMixture(n_components=9, covariance_type='tied', random_state=42).fit_predict(features_reduced_local).reshape(B, H, W)

kmeans_sample_results = evaluate_segmentation_quality(features_reduced_local, kmeans_masks.flatten(), "KMeans (Samples)")
gmm_sample_results = evaluate_segmentation_quality(features_reduced_local, gmm_masks.flatten(), "GMM+PCA (Samples)")

sample_results = {
    'KMeans': kmeans_sample_results,
    'GMM': gmm_sample_results
}
best_sample = compare_methods(sample_results)

# Visualize segmentations for selected samples
print("\n Individual Sample Analysis:")
for i in range(B):
    print(f"\nImage {indices[i]}:")
    print(f"  KMeans: {len(np.unique(kmeans_masks[i]))} segments")
    print(f"  GMM:    {len(np.unique(gmm_masks[i]))} segments")

fig, axes = plt.subplots(B, 3, figsize=(12, 4 * B))

for i in range(B):
    orig = selected_imgs[i].permute(1, 2, 0).cpu().numpy()
    axes[i, 0].imshow(orig)
    axes[i, 0].set_title("Original")
    axes[i, 1].imshow(kmeans_masks[i], cmap='tab10')
    axes[i, 1].set_title("KMeans Segmentation")
    axes[i, 2].imshow(gmm_masks[i], cmap='tab10')
    axes[i, 2].set_title("GMM Segmentation")
    for j in range(3):
        axes[i, j].axis('off')

plt.tight_layout()
plt.show()